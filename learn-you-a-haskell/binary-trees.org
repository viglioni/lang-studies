#+Title: Binary Trees
#+startup: fold
#+name: org-clear-haskell-output
#+begin_src emacs-lisp :var strr="" :exports none
    (format "%s" (replace-regexp-in-string
                  (rx (and (| "*Main" "Prelude") (? "|") (? ">"))) "" (format "%s" strr)))
    
#+end_src

#+RESULTS: org-clear-haskell-output

In this file we will define trees and some related functions


** Type
   #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
     :{
      
     data BinTree a
       = EmptyTree
       | Node a (BinTree a) (BinTree a)
      
     instance Show a => Show (BinTree a) where
       show EmptyTree = " _"
       show (Node a left right) =
         " (" ++ (show a) ++ (show left) ++ (show right) ++ ")"
      
     instance Functor BinTree where
       fmap f EmptyTree = EmptyTree
       fmap f (Node a left right) = Node (f a) (fmap f left) (fmap f right)
      
     :}
   #+end_src

   #+RESULTS:
** Functions
*** Create single node (leaf)
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      :{
      
      leaf :: a -> BinTree a  
      leaf a = Node a EmptyTree EmptyTree
      
      :}
    #+end_src

    #+RESULTS:
*** Insert node
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      :{
      
      insertNode :: (Ord a) => BinTree a -> a -> BinTree a
      insertNode EmptyTree value = leaf value
      insertNode tree value
        | value == nodeValue = Node value left right
        | value < nodeValue = Node nodeValue (insertNode left value) right
        | value > nodeValue = Node nodeValue left (insertNode right value)
        where
          (Node nodeValue left right) = tree
      
      :}
    #+end_src

    #+RESULTS:
*** Searching for node
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      :{
      
      elemTree :: (Ord a) => BinTree a -> a -> Bool
      elemTree EmptyTree _ = False
      elemTree tree value
        | nodeValue == value = True
        | nodeValue < value = elemTree rightTree value
        | nodeValue > value = elemTree leftTree value
        where
          (Node nodeValue leftTree rightTree) = tree
      
      :}
    #+end_src

    #+RESULTS:
*** List from tree
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      :{
      
      listFromTree :: BinTree a -> [a]
      listFromTree EmptyTree = []
      listFromTree (Node val leftTree rightTree) =
        val : (listFromTree leftTree) ++ (listFromTree rightTree)
      
      :}
    #+end_src

    #+RESULTS:
*** Get all leafs
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      :{
      
      leafs :: BinTree a -> [a]
      leafs EmptyTree = []
      leafs (Node val EmptyTree EmptyTree) = [val]
      leafs (Node _ leftTree rightTree) = (leafs leftTree) ++ (leafs rightTree)
      
      :}
    #+end_src

    #+RESULTS:
*** Count nodes
     #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
       :{
      
       countNodes :: BinTree a -> Int
       countNodes EmptyTree = 0
       countNodes (Node _ leftTree rightTree) =
         1 + (countNodes leftTree) + (countNodes rightTree)
      
       :}
 #+end_src

 #+RESULTS:

** Executing functions
*** Creating a leaf
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      leaf 10
    #+end_src

    #+RESULTS:
    : (10 _ _)

    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      leaf  "string node"
    #+end_src

    #+RESULTS:
    : (string node _ _)

*** Creating a binary tree from a list
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      foldl insertNode EmptyTree [4,2,1,3,9,7,6,8]
    #+end_src

    #+RESULTS:
    : (4 (2 (1 _ _) (3 _ _)) (9 (7 (6 _ _) (8 _ _)) _))

*** Applying fmap on a tree, i.e. trees as functors
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      tree = foldl insertNode EmptyTree [4,2,1,3,9,7,6,8]
      fmap (* 10) tree       
    #+end_src

    #+RESULTS:
    : (40 (20 (10 _ _) (30 _ _)) (90 (70 (60 _ _) (80 _ _)) _))

*** Checking if an element is in the tree
     
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      tree = foldl insertNode EmptyTree [4,2,1,3,9,7,6,8]
      zip [1..10] $ map (elemTree tree) [1..10]
    #+end_src

    #+RESULTS:
    : ((1 True) (2 True) (3 True) (4 True) (5 False) (6 True) (7 True) (8 True) (9 True) (10 False))

*** List from a tree
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      tree = foldl insertNode EmptyTree [4,2,1,3,9,7,6,8]
      listFromTree tree
    #+end_src

    #+RESULTS:
    : (4 2 1 3 9 7 6 8)

*** Get all leafs form a tree
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      tree = foldl insertNode EmptyTree [4,2,1,3,9,7,6,8]
      leafs tree
    #+end_src

    #+RESULTS:
    : (1 3 6 8)

*** Count nodes from a tree
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      tree = foldl insertNode EmptyTree [4,2,1,3,9,7,6,8]
      countNodes tree
    #+end_src

    #+RESULTS:
    : 8
